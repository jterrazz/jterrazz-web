---
description: Comprehensive Clean Architecture & Development Rules for Web
alwaysApply: true
---

# ğŸ—ï¸ Perfect Web Architecture

These rules codify how this Next.js project is structured to ensure code remains **predictable, scalable, and testable**.

> "UI is just a function of state â€“ keep state clean and the UI will follow." â€“ Rule #0

---

## 1. Architecture Overview

### 1.1 Directory Organization

We follow a pragmatic **Clean Architecture** split into four main layers, plus root configuration and injection.

```
src/
â”œâ”€â”€ config/                             # âš™ï¸ Global Configuration
â”‚   â””â”€â”€ env.ts                          #    (Environment variables, API URLs)
â”‚
â”œâ”€â”€ domain/                             # ğŸ”´ INNERMOST: Pure Business Logic
â”‚   â”œâ”€â”€ entities/                       #    (Mutable domain objects with identity)
â”‚   â”œâ”€â”€ value-objects/                  #    (Immutable domain attributes)
â”‚   â””â”€â”€ errors/                         #    (Domain-specific errors)
â”‚
â”œâ”€â”€ application/                        # ğŸŸ¡ INNER: Application Orchestration
â”‚   â”œâ”€â”€ ports/                          # ğŸ”Œ The Contracts (Interfaces)
â”‚   â”‚   â”œâ”€â”€ {feature}-repository.port.ts
â”‚   â”‚   â””â”€â”€ {service}.port.ts
â”‚   â””â”€â”€ use-cases/                      # âš¡ï¸ The Actions (Class-based)
â”‚       â””â”€â”€ {feature}/
â”‚           â”œâ”€â”€ {verb}-{noun}.use-case.ts
â”‚           â””â”€â”€ {verb}-{noun}.dto.ts
â”‚
â”œâ”€â”€ infrastructure/                     # ğŸŸ¢ OUTER: Adapters & Implementations
â”‚   â”œâ”€â”€ repositories/                   # ğŸ’¾ Persistence Adapters (Implement Ports)
â”‚   â”œâ”€â”€ api/                            # ğŸŒ Network Adapters (Fetch/Axios)
â”‚   â”œâ”€â”€ stores/                         # ğŸ“¦ Local State Definitions (Zustand)
â”‚   â”œâ”€â”€ persistence/                    # ğŸ’¾ Low-level Storage (localStorage, cookies)
â”‚   â””â”€â”€ internationalization/           # ğŸŒ I18n logic & locales
â”‚
â”œâ”€â”€ presentation/                       # ğŸ”µ OUTERMOST: UI & Interaction
â”‚   â”œâ”€â”€ theme/                          # ğŸ¨ Design System (Tokens, Providers)
â”‚   â”œâ”€â”€ ui/                             # ğŸ§± Dumb Components (Atomic Design)
â”‚   â”‚   â”œâ”€â”€ atoms/                      #    (Single responsibility primitives)
â”‚   â”‚   â”œâ”€â”€ molecules/                  #    (Composition of atoms)
â”‚   â”‚   â””â”€â”€ organisms/                  #    (Complex standalone sections)
â”‚   â”œâ”€â”€ templates/                      # ğŸ“„ Page layouts (compose organisms)
â”‚   â””â”€â”€ hooks/                          # âš“ï¸ Global Presentation Hooks
â”‚
â”œâ”€â”€ app/                                # ğŸ“± Next.js App Router
â”‚   â”œâ”€â”€ (routes)/                       #    (Route groups & pages)
â”‚   â”œâ”€â”€ api/                            #    (API routes / Route Handlers)
â”‚   â”œâ”€â”€ layout.tsx                      #    (Root layout)
â”‚   â””â”€â”€ page.tsx                        #    (Home page)
â”‚
â””â”€â”€ di/                                 # ğŸ’‰ Dependency Injection
    â””â”€â”€ container.ts                    #    (Wiring: Ports â†’ Implementations)
```

### 1.2 File Naming Conventions

| Layer | Type | Filename Pattern | Export Pattern |
| :--- | :--- | :--- | :--- |
| **Domain** | Entity | `{name}.entity.ts` | `{Name}` |
| | Value Object | `{name}.vo.ts` | `{Name}` |
| **App** | Port | `{name}.port.ts` | `{Name}Port` |
| | Use Case | `{verb}-{noun}.use-case.ts` | `{Verb}{Noun}UseCase` |
| **Infra** | Repository | `{name}.repository.ts` | `{Name}Repository` |
| | API Adapter | `{name}.api.ts` | `{Name}Api` |
| | Store | `{name}.store.ts` | `use{Name}Store` |
| **UI** | Component | `{name}/{name}.tsx` | `{Name}` |
| | Sub-component | `{parent}/{parent}-{child}.tsx` | `{Parent}{Child}` |
| | Hook | `use-{hook-name}.ts` | `use{HookName}` |
| | Context | `{name}-context.tsx` | `{Name}Context`, `use{Name}` |

---

## 2. Dependency Rules

Strict unidirectional data flow. Inner layers **never** know about outer layers.

```mermaid
graph TD
    Presentation --> Application
    Infrastructure --> Application
    Application --> Domain
    Domain --> Nothing
```

*   **Presentation**: Imports `Application` (Use Cases) and `Domain` (Types). NEVER imports `Infrastructure`.
*   **Infrastructure**: Imports `Application` (Ports) and `Domain`.
*   **Application**: Imports `Domain`. Defines Ports implemented by Infrastructure.
*   **Domain**: Pure TypeScript. No framework dependencies.

---

## 3. Presentation Layer Guidelines

The presentation layer is strictly organized to separate **visuals** from **behavior**.

### 3.1 Atomic Design (`src/presentation/ui`)
Reusable, feature-agnostic components located in the `ui/` folder.
Each component lives in its **own folder** named after the component.

```
ui/
â”œâ”€â”€ atoms/
â”‚   â”œâ”€â”€ badge/badge.tsx
â”‚   â”œâ”€â”€ button-link/button-link.tsx
â”‚   â””â”€â”€ heading-h1/heading-h1.tsx
â”œâ”€â”€ molecules/
â”‚   â”œâ”€â”€ card-article/card-article.tsx
â”‚   â””â”€â”€ toggle-theme/toggle-theme.tsx
â””â”€â”€ organisms/
    â”œâ”€â”€ navbar/
    â”‚   â”œâ”€â”€ navbar.tsx
    â”‚   â””â”€â”€ navbar-page.ts
    â””â”€â”€ site-footer/site-footer.tsx
```

*   **Atoms**: Basic building blocks (Badge, Button, Heading). No logic.
*   **Molecules**: Groups of atoms (Card, Toggle, Selector). UI logic only.
*   **Organisms**: Complex UI sections (Navbar, Footer, Table). Can have local state and sub-components.

### 3.2 Templates (`src/presentation/templates`)
Page layouts that compose organisms. Used by `app/` routes.

### 3.3 UI Component Naming

**Use primitive names** â€” name by WHAT it is, not HOW it behaves.

| âŒ Avoid | âœ… Prefer | Reason |
| :--- | :--- | :--- |
| `expandable-navbar` | `navbar` | Behavior is implementation detail |
| `animated-card` | `card` | Document behavior in JSDoc |
| `collapsible-header` | `header` | Findability: devs search "header" |

**Rules:**
*   Name components by their **UI primitive** (Button, Card, Modal, Navbar)
*   Document behavior in JSDoc: `@description Expandable navbar with gesture support`
*   Only add behavior prefix if you have **multiple variants**: `simple-navbar` vs `rich-navbar`

**Sub-component naming:** `{parent}-{child}.tsx`
```
organisms/navbar/
â”œâ”€â”€ navbar.tsx              # Main component
â”œâ”€â”€ navbar-tab.tsx          # Sub-component
â”œâ”€â”€ navbar-menu.tsx         # Sub-component
â”œâ”€â”€ navbar-menu-item.tsx    # Sub-component
â””â”€â”€ use-navbar-gesture.ts   # Hook
```

### 3.4 Component Anatomy & Co-location

**Principle: Co-locate until you need to share.**

Each component is **self-contained** with styles, constants, and helpers inline:

```tsx
// navbar-tab.tsx (self-contained component)
import { cn } from '@/lib/utils';

// 1. Constants (if needed)
const ANIMATION_DURATION = 300;

// 2. Types
interface NavbarTabProps { ... }

// 3. Component
export function NavbarTab({ className, ...props }: NavbarTabProps) {
  return (
    <div className={cn('flex items-center', className)} {...props}>
      ...
    </div>
  );
}
```

**Folder structure for complex components:**

```
organisms/navbar/
â”œâ”€â”€ navbar.tsx                 # Main orchestrator (thin)
â”œâ”€â”€ navbar-tab.tsx             # Sub-component (self-contained)
â”œâ”€â”€ navbar-menu.tsx            # Expanded menu container
â”œâ”€â”€ navbar-menu-item.tsx       # Sub-component (self-contained)
â”œâ”€â”€ navbar-expand-trigger.tsx  # The "more" button
â”œâ”€â”€ use-navbar-gesture.ts      # Hook (stateful logic)
â””â”€â”€ __tests__/

atoms/button-link/
â””â”€â”€ button-link.tsx            # Simple atom (single file)

molecules/card-article/
â”œâ”€â”€ card-article.tsx           # Main component
â””â”€â”€ card-article-image.tsx     # Sub-component (if needed)
```

**When to extract:**

| Extract to... | When... |
| :--- | :--- |
| **Separate hook** (`use-*.ts`) | Stateful logic with `useState`/`useRef`/`useCallback` |
| **Separate file** | Used by 3+ components in same folder |
| **Keep inline** | Small helpers, single-use configs |

**âŒ DON'T create:**
*   `{name}.styles.ts` â€” use Tailwind classes inline
*   `{name}.constants.ts` â€” constants go inside component file
*   Shared styles files â€” each sub-component owns its styles

### 3.5 Theme & Design System (`src/presentation/theme`)
Contains theme types, providers, and design tokens.
*   **Tokens**: Colors, Spacing, Typography defined in Tailwind config.
*   **Usage**: Never hardcode hex codes or pixels. Use Tailwind classes.
    *   âœ… `className="text-zinc-900 dark:text-zinc-100"`
    *   âŒ `style={{ color: '#F00' }}`

---

## 4. Implementation Guidelines

### 4.1 Coding Style
1.  **Functional & Declarative**: Use React Functional Components and Hooks.
2.  **Early Returns**: Avoid deep nesting. Guard clauses first.
3.  **Props**: Define `interface {Name}Props` inside the `.tsx` file. Avoid "Props drilling" > 2 levels.
4.  **No Barrel Exports**: Do not use `index.ts` files. Import directly from specific files to avoid circular dependencies and tree-shaking issues.

### 4.2 Server vs Client Components
1.  **Server Components (default)**: Data fetching, heavy computation, sensitive logic.
2.  **Client Components (`'use client'`)**: Interactivity, browser APIs, hooks with state.
3.  **Rule**: Keep client boundary as low as possible in the component tree.

### 4.3 State Management
1.  **Local State**: `useState` for ephemeral UI state (isMenuOpen).
2.  **Feature State**: `useReducer` or Custom Hooks for complex local logic.
3.  **Global State**: **Zustand** stores located in `infrastructure/stores`.
    *   Access strictly via Repositories in Use Cases (Logic).
    *   Access via Hooks in UI (Reading data).
4.  **Server State**: Prefer Server Components for data fetching when possible.

### 4.4 Error Handling
*   **Domain/App**: Throw typed Errors (e.g., `ArticleNotFoundError`).
*   **UI**: Handle errors in Custom Hooks or strictly typed `Result` objects.
*   **Global**: Use Error Boundaries and Next.js `error.tsx` for crashes.

---

## 5. Testing Strategy

*   **Unit Tests**: Colocated `__tests__` folder.
    *   `{name}.test.ts` for logic/classes.
    *   `{name}.test.tsx` for components (Testing Library).
*   **Focus**: Test **behavior**, not implementation details.
*   **Mocks**: Mock external dependencies (Ports) when testing Use Cases.

---

## 6. Best Practices Checklist

### âœ… DO
*   Validate external data (API, Storage) with **Zod** at the Infrastructure boundary.
*   Use **Dependency Injection** for all Use Cases and Repositories.
*   Keep UI components "dumb" â€” pass data in, get events out.
*   **Co-locate** styles, constants, and helpers inside component files.
*   Make each sub-component **self-contained** and portable.
*   Use `useCallback` / `useMemo` for referenced functions/values in `useEffect`.
*   Use **kebab-case** for all filenames: `navigation-bar-tab.tsx`.
*   Prefer **Server Components** for data fetching and static content.

### âŒ DON'T
*   Import `infrastructure` files directly into `presentation`.
*   Put business logic (calculations, filtering) in UI components.
*   Create generic `utils/` folders. Name them by domain (e.g., `date-utils`, `string-utils`).
*   Leave `console.log` in production code.
*   Create new documentation files unless requested.
*   Use `index.ts` files for barrel exports.
*   Create separate `.styles.ts` or `.constants.ts` files â€” co-locate instead.
*   Use dot notation in filenames (`component.tab.tsx`) â€” use kebab-case (`component-tab.tsx`).
*   Add `'use client'` unnecessarily â€” keep client boundaries minimal.
