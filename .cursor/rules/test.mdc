---
description: Testing guidelines for unit, integration, and e2e tests
alwaysApply: true
---

# üß™ Testing Standards

These rules codify how every test suite should be structured so that tests remain **reliable, readable, and effortless to maintain**.

> "Test behaviour, not implementation ‚Äì focus on what the code does, not how it does it." ‚Äì Rule #0

---

## 1. Test Strategy

### Testing Pyramid

```
    /\     E2E Tests
   /  \    ‚Ä¢ Critical user workflows
  /____\   ‚Ä¢ Slow, expensive, selective
 /      \
/________\
|        | Integration Tests
|        | ‚Ä¢ Cross-layer interactions
|        | ‚Ä¢ Real dependencies, mocked externals
|________| ‚Ä¢ Medium speed, targeted coverage
|        |
|        | Unit Tests
|        | ‚Ä¢ Pure business logic
|        | ‚Ä¢ Fast, isolated, comprehensive
|________|
```

### Test Types & When to Use

| Test Type       | Purpose                  | Speed  | Location                 |
| --------------- | ------------------------ | ------ | ------------------------ |
| **Unit**        | Pure logic, domain rules | Fast   | Alongside source files   |
| **Integration** | Cross-layer workflows    | Medium | `__tests__/integration/` |
| **E2E**         | Critical user journeys   | Slow   | `__tests__/e2e/`         |
| **Contract**    | External API boundaries  | Medium | `infrastructure/api/`    |

---

## 2. Directory Structure

```
<repo>
  src/
  ‚îú‚îÄ‚îÄ {feature}.ts
  ‚îî‚îÄ‚îÄ __tests__/
      ‚îî‚îÄ‚îÄ {feature}.test.ts                  # Colocated unit tests

  __tests__/                                 # Integration tests & shared utilities
  ‚îú‚îÄ‚îÄ integration/
  ‚îÇ   ‚îî‚îÄ‚îÄ {feature}.integration.test.ts      # Integration tests
  ‚îú‚îÄ‚îÄ e2e/
  ‚îÇ   ‚îî‚îÄ‚îÄ {workflow}.e2e.test.ts             # E2E tests
  ‚îú‚îÄ‚îÄ fixtures/
  ‚îÇ   ‚îî‚îÄ‚îÄ {entity}.factory.ts                # Domain object factories
  ‚îú‚îÄ‚îÄ providers/                             # MSW handlers for external services
  ‚îÇ   ‚îî‚îÄ‚îÄ com.{domain}.api/
  ‚îÇ       ‚îî‚îÄ‚îÄ {service}-endpoint.resolver.ts
  ‚îî‚îÄ‚îÄ setup/
      ‚îú‚îÄ‚îÄ integration.ts                     # Test context setup
      ‚îî‚îÄ‚îÄ test-utils.ts                      # Helper utilities
```

### Core Principles

- **Unit tests**: Always colocated with source code in `__tests__/` folders
- **Integration tests**: In `__tests__/integration/`, test cross-layer interactions
- **E2E tests**: In `__tests__/e2e/`, test complete workflows
- **Test utilities**: Centralized in `__tests__/setup/` for reusability

---

## 3. Naming Conventions

| Type             | Pattern                          | Example                                                               |
| ---------------- | -------------------------------- | --------------------------------------------------------------------- |
| **Unit test**    | `{name}.test.ts[x]`              | `src/{feature}/__tests__/{feature}.test.ts`                           |
| **Integration**  | `{name}.integration.test.ts`     | `__tests__/integration/{feature}.integration.test.ts`                 |
| **E2E test**     | `{workflow}.e2e.test.ts`         | `__tests__/e2e/{verb}-{entity}.e2e.test.ts`                           |
| **Factory**      | `{entity}.factory.ts`            | `__tests__/fixtures/{entity}.factory.ts`                              |
| **MSW Provider** | `{service}-endpoint.resolver.ts` | `__tests__/providers/com.{domain}.api/{service}-endpoint.resolver.ts` |
| **Test Helper**  | `{purpose}.ts`                   | `__tests__/setup/{purpose}.ts`                                        |

---

## 4. Test File Structure

Every test file follows this order:

```typescript
// 1. Imports (with .js extensions for ESM)
import { describe, it, expect, beforeAll, afterEach } from '@jterrazz/test';
import { UserFactory } from '../fixtures/user.factory.js';

// 2. Test data setup & MSW handlers
const mockUserData = UserFactory.build();

// 3. Test hooks
beforeAll(async () => {
    /* setup */
});
afterEach(async () => {
    /* cleanup */
});

// 4. Test suites
describe('User Entity', () => {
    describe('validation', () => {
        it('accepts valid email formats', () => {
            // Given ‚Äì valid email input
            const email = 'user@example.com';

            // When ‚Äì creating user
            const user = User.create({ email, name: 'Test User' });

            // Then ‚Äì user is valid
            expect(user.isValid()).toBe(true);
        });
    });
});
```

---

## 5. Writing Tests

### Structure Guidelines

- Use **Given/When/Then** comments for clarity
- Prefer `it` over `test` for readability
- Group related scenarios with nested `describe` blocks
- Focus on **observable behaviour**, not implementation

### Integration Test Example

```typescript
import { describe, it, expect, beforeAll } from '@jterrazz/test';
import { createIntegrationContext, executeRequest } from '../setup/integration.js';

describe('User Registration API', () => {
    let context: IntegrationContext;

    beforeAll(async () => {
        context = await createIntegrationContext();
    });

    it('creates user and returns confirmation', async () => {
        // Given ‚Äì valid registration data
        const userData = { email: 'test@example.com', password: 'secure123' };

        // When ‚Äì submitting registration
        const response = await executeRequest(context, 'POST', '/users', userData);

        // Then ‚Äì user is created successfully
        expect(response.status).toBe(201);
        expect(response.body).toMatchObject({
            id: expect.any(String),
            email: userData.email,
        });
    });
});
```

---

## 6. Test Utilities & Patterns

### Integration Context Pattern

```typescript
// __tests__/setup/integration.ts
export interface IntegrationContext {
    db: Database;
    server: TestServer;
    msw: SetupServer;
}

export async function createIntegrationContext(): Promise<IntegrationContext> {
    // Setup temporary database, test server, MSW handlers
}
```

### Domain Factories

```typescript
// __tests__/fixtures/user.factory.ts
export class UserFactory {
    static build(overrides?: Partial<User>): User {
        return {
            id: crypto.randomUUID(),
            email: 'test@example.com',
            name: 'Test User',
            createdAt: new Date(),
            ...overrides,
        };
    }
}
```

### MSW Providers

```typescript
// __tests__/providers/com.auth.api/auth-service-endpoint.resolver.ts
import { http, setupServer } from 'msw';

export const authServiceHandlers = [
    http.post('/api/auth/login', ({ request }) => {
        return new Response(JSON.stringify({ token: 'mock-jwt-token' }));
    }),
];

// Setup MSW server for integration tests
export const server = setupServer(...authServiceHandlers);
```

---

## 7. Best Practices

- ‚úÖ **DO** write behaviour-driven test titles
- ‚úÖ **DO** use Given/When/Then structure
- ‚úÖ **DO** reset state between tests
- ‚úÖ **DO** keep unit tests fast (‚â§ 200ms)
- ‚úÖ **DO** use real databases for integration tests
- ‚úÖ **DO** mock external services with MSW

- ‚ùå **DON'T** test implementation details
- ‚ùå **DON'T** use multiple logical assertions per `it`
- ‚ùå **DON'T** skip test data cleanup
- ‚ùå **DON'T** ignore linting rules in test code
- ‚ùå **DON'T** hardcode test data (use factories)
