---
description: TypeScript standards for type-safe, readable, and maintainable code
alwaysApply: true
---

# üè∑Ô∏è TypeScript Standards

These rules codify how every TypeScript codebase should be structured so that code remains **type-safe, readable, and maintainable**.

> "Make invalid states unrepresentable ‚Äì use the type system to prevent bugs." ‚Äì Rule #0

---

## 1. Import Order & Syntax

1. **External packages** ‚Üí blank line ‚Üí **`@/*` aliases** ‚Üí blank line ‚Üí **relative imports**.
2. Use **type-only** imports: `import type { X } from "‚Ä¶"`.
3. Relative imports **always** end with `.js` extension (ESM output friendly).
4. ‚ö†Ô∏è **Auto-fix warning** ‚Äì our linter deletes **unused** imports on save. If you add imports _before_ the code that uses them, they will be wiped. ‚Üí Write the code first, then add the import to avoid churn.

```ts
import { z } from "zod";
import type { Context } from "hono";

import { type {Entity}RepositoryPort } from "@/application/ports/outbound/persistence/{entity}-repository.port.js";

import { {Value} } from "./{value}.vo.js";
```

---

## 2. Compiler Flags

| Flag                          | Value |
| ----------------------------- | :---: |
| `strict`                      |  ‚úÖ   |
| `noImplicitReturns`           |  ‚úÖ   |
| `noUnusedLocals / Parameters` |  ‚úÖ   |
| `exactOptionalPropertyTypes`  |  ‚úÖ   |
| `noUncheckedIndexedAccess`    |  ‚úÖ   |

---

## 3. Naming Conventions

| Kind             | Example                            |
| ---------------- | ---------------------------------- |
| Interface / Type | `UserProfile`                      |
| Class            | `WorldNews`, `GetArticlesUseCase`  |
| Enum             | `StatusEnum`                       |
| Constant         | `API_BASE_URL`, `RATE_LIMIT_DELAY` |
| Zod schema var   | `categorySchema`                   |
| Port interface   | `ArticleRepositoryPort`            |

---

## 4. Import/Export Conventions

### 4.1 Import Order & Style

```typescript
// 1. External dependencies
import { z } from "zod";
import type { Context } from "hono";

// 2. Internal ports/interfaces (type-only)
import type { {Entity}RepositoryPort } from "@/application/ports/outbound/persistence/{entity}-repository.port.js";

// 3. Internal implementations (relative imports)
import { {Entity}Provider } from "../providers/{entity}.provider.js";
```

**Requirements:**

- Always use **`.js` extension** for imports (for ES module compatibility)
- Use **`type`** imports for type-only imports
- Use relative paths for internal modules

### 4.2 No Barrel Exports

**Requirements:**

- Do **NOT** use `index.ts` files to group exports.
- Import directly from the specific file where the symbol is defined.
- This improves tree-shaking, reduces circular dependencies, and makes code navigation clearer.

```typescript
// ‚úÖ Good
import { Article } from "./entities/article.entity.js";
import { Category } from "./value-objects/category.vo.js";

// ‚ùå Bad
import { Article, Category } from "./index.js";
```

---

## 5. Type Definitions

### 5.1 Interface vs Type Usage

- Use **interfaces** for object shapes and contracts
- Use **type aliases** for unions, primitives, and computed types
- Always export option interfaces alongside classes
- Use generic types for reusable components

```typescript
// ‚úÖ Use interfaces for object shapes
interface UserProfile {
  id: string;
  name: string;
  email: string;
}

// ‚úÖ Use type aliases for unions
type Status = "pending" | "completed" | "failed";

// ‚úÖ Export options alongside classes
export interface {Entity}ServiceOptions {
  timeout: number;
  retryCount: number;
}

export class {Entity}Service {
  constructor(private readonly options: {Entity}ServiceOptions) {}
}
```

### 5.2 Class Design Standards

- Use readonly properties for configuration
- Private methods for internal logic
- Clear, descriptive method and property names
- Explicit access modifiers

```typescript
export class {Entity}Processor {
  constructor(
    private readonly config: ProcessorConfig,
    private readonly logger: Logger
  ) {}

  // Public API - clear intention
  async processEntity(entity: Entity): Promise<ProcessedEntity> {
    this.validateInput(entity);
    return this.executeProcessing(entity);
  }

  // Private implementation details
  private validateInput(entity: Entity): void {
    // Validation logic
  }

  private async executeProcessing(entity: Entity): Promise<ProcessedEntity> {
    // Processing logic
  }
}
```

---

## 6. Code Style Guidelines

‚Ä¢ **Explicit return types** for every exported function / method.
‚Ä¢ Max **3 parameters** ‚Äì otherwise use an options object.
‚Ä¢ Prefer **arrow functions** for class properties.
‚Ä¢ Always mark injected deps `private readonly`.
‚Ä¢ Early returns + guard clauses; avoid deep nesting.
‚Ä¢ Class member order: public props ‚Üí private props ‚Üí constructor ‚Üí public methods ‚Üí private methods.

---

## 7. Error Handling Pattern

- Distinguish **expected** vs **unexpected** errors with dedicated classes.
- Value objects use `schema.safeParse` and throw descriptive errors.
- Use typed `Result<E, T>` return values for expected errors.
- Unexpected errors should be thrown and captured by framework-level error boundaries.

---

## 8. Domain Modeling with Zod

### Value Object Example

```ts
export const {value}Schema = z
  .enum(["{VALUE_A}", "{VALUE_B}", "{VALUE_C}"])
  .describe("{Entity} {value}");
export type {Value}Enum = z.infer<typeof {value}Schema>;

export class {Value} {
  constructor(private readonly value: {Value}Enum) {}
  toString() {
    return this.value;
  }
  static create(raw: string): {Value} {
    const res = {value}Schema.safeParse(raw);
    if (!res.success) throw new Error(`Invalid {value}: ${raw}`);
    return new {Value}(res.data);
  }
}
```

- Schemas live **above** classes/types and are exported with `as const`.
- Always export the inferred type: `export type X = z.infer<typeof xSchema>`.

---

## 9. Async Patterns

- Prefer `async/await`; never chain `.then()`.
- Use `Promise.all([...])` for parallel I/O.
- Async functions have explicit return types: `Promise<T>`.
- Fail fast: validate input early, short-circuit when possible.

---

## 10. Dependency Injection Pattern

### 10.1 Constructor Injection

```typescript
export interface {Entity}Options {
  // Configuration options
}

/**
 * Implementation with dependency injection
 */
export class {Entity}Service {
  constructor(
    public readonly name: string,
    private readonly options: {Entity}Options,
    private readonly repository: {Entity}RepositoryPort
  ) {}

  async execute(input: string): Promise<string> {
    // Implementation
  }
}
```

**Requirements:**

- Use constructor injection for dependencies
- Make dependencies `private readonly`
- Accept configuration through options interfaces

---

## 11. Configuration Objects

- Use explicit interfaces (`{Service}Config`).
- Validate at bootstrap with Zod.
- Keep config separate from business logic.

---

## 12. Documentation

### 12.1 JSDoc Standards

```typescript
/**
 * Port definition for {entity} operations
 * @description Handles {entity} business logic operations
 */
export interface {Entity}Port {
  /**
   * Executes the main {entity} operation
   * @param input - The input data to process
   * @returns Promise resolving to processed result
   * @throws {ValidationError} When input is invalid
   */
  execute(input: string): Promise<string>;
}
```

#### Component JSDoc Example

```typescript
// Props documented with JSDoc; each public prop must be described
export interface PillButtonProps {
    /**
     * Text content to display inside the button
     */
    label: string;

    /**
     * Press handler invoked when the button is activated
     */
    onPress: () => void;

    /**
     * Visual importance (affects background, border, and text colors)
     * @default "primary"
     */
    variant?: 'primary' | 'secondary' | 'ghost';

    /**
     * Accessibility label announced by screen readers
     */
    accessibilityLabel?: string;
}

/**
 * Pill-shaped, high-contrast CTA button
 * @description Semantic button component following the design system (pill shape, bold border, compact height). Focuses on clarity and accessibility.
 * @remarks Always set `accessibilityRole="button"` and provide a meaningful `accessibilityLabel`.
 * @param props - {@link PillButtonProps} configuration
 * @returns JSX.Element
 */
export function PillButton(props: PillButtonProps) {
    // Implementation omitted ‚Äì focus is on JSDoc structure
    return null;
}
```

**Requirements:**

- All public classes and interfaces must have JSDoc
- Include `@description` for interfaces and major classes
- Document parameters, return types, and thrown errors
- Explain **why**, not **how**

---

## 13. Best Practices

- ‚úÖ **DO** respect import order & use `.js` extensions
- ‚úÖ **DO** enable strict compiler flags
- ‚úÖ **DO** follow naming table conventions
- ‚úÖ **DO** use early returns over nested `if`s
- ‚úÖ **DO** validate Zod schemas at boundaries
- ‚úÖ **DO** provide descriptive error messages
- ‚úÖ **DO** fully type & document public APIs

- ‚ùå **DON'T** use more than 3 function parameters
- ‚ùå **DON'T** mix expected and unexpected error handling
- ‚ùå **DON'T** skip type annotations on exported functions
