![](assets/thumbnail.jpg)

# La Clean Architecture: Le MÃ©tier Avant Tout

## Revenons Ã  L'essentiel

Voici l'idÃ©e qui a changÃ© ma faÃ§on de dÃ©velopper: votre architecture ne devrait pas se soucier de votre base de donnÃ©es. Ni de votre framework web. Ni de votre interface utilisateur. La seule chose qui devrait l'importer, c'est ce que votre application *fait* rÃ©ellement.

C'est toute la philosophie de la **Clean Architecture**. C'est une maniÃ¨re de construire des logiciels qui place vos **cas d'utilisation** (*use cases*)â€”la vraie valeur mÃ©tierâ€”au centre absolu de tout. Le reste n'est qu'un dÃ©tail. C'est une Ã©volution puissante des idÃ©es que nous avons vues avec l'Architecture Hexagonale, mais avec des rÃ¨gles plus strictes qui vous apportent encore plus de clartÃ© et de puissance.

**Navigation ğŸ“š**

1. [**Introduction : Le Design Applicatif, l'Art de Construire des Logiciels Durables et Ã‰volutifs**](https://www.jterrazz.com/articles/9-software-design-0-why-architecture-matters/fr)
		*Les bases pour comprendre les enjeux et les objectifs d'une bonne architecture.*

2. [**Chapitre 1 : Le Concept de DÃ©pendances**](https://www.jterrazz.com/articles/10-software-design-1-mastering-dependencies/fr)
		*Explorer les relations entre composants, l'importance des dÃ©pendances et les principes comme SOLID.*

3. [**Chapitre 2 : Comprendre les Architectures MÃ©tier et Technique**](https://www.jterrazz.com/articles/11-software-design-2-hexagonal-architecture/fr)
		*Comprendre comment isoler le mÃ©tier des prÃ©occupations techniques grÃ¢ce aux ports et adaptateurs.*

4. [**Chapitre 3 : La Clean Architecture**](https://www.jterrazz.com/articles/12-software-design-3-clean-architecture-in-practice/fr)
		*DÃ©couvrir une approche centrÃ©e sur le mÃ©tier avec une structuration claire en couches.*

---

## La Clean Architecture En ThÃ©orie

La Clean Architecture, c'est avant tout une histoire de couches indÃ©pendantes avec des rÃ¨gles de communication strictes. Imaginez des cercles concentriques, comme un oignon.

1. **Les EntitÃ©s (Entities)**: Au cÅ“ur du rÃ©acteur. Ce sont les rÃ¨gles mÃ©tier de votre entreprise. La logique pure, sans fioritures, qui dÃ©finit votre business.
2. **Les Cas d'Utilisation (Use Cases)**: La couche qui entoure les entitÃ©s. Elle contient les rÃ¨gles mÃ©tier spÃ©cifiques Ã  l'application. C'est le chef d'orchestre qui organise les flux de donnÃ©es avec les entitÃ©s pour atteindre un but prÃ©cis (ex: "Inscrire un utilisateur").
3. **Les Adaptateurs d'Interface (Interface Adapters)**: La couche de traduction. Elle prend les donnÃ©es dans le format pratique pour les use cases et les entitÃ©s, et les convertit dans le format pratique pour le monde extÃ©rieur (la base de donnÃ©es, le web, etc.).
4. **Les Frameworks et Drivers**: La couche la plus externe. C'est lÃ  que vivent tous les dÃ©tails: le framework web, la base de donnÃ©es, l'UIâ€¦ C'est cette couche qui est la plus susceptible de changer.

La rÃ¨gle d'or est la **RÃ¨gle de DÃ©pendance**: toutes les dÃ©pendances doivent pointer vers l'intÃ©rieur. Votre UI peut dÃ©pendre de vos use cases, mais vos use cases, eux, ne savent MÃŠME PAS que l'UI existe. Votre logique mÃ©tier est reine, et elle n'est jamais, au grand jamais, dÃ©trÃ´nÃ©e par un dÃ©tail technique.

![](assets/clean-architecture.jpg)

---

## Clean Architecture vs. Architecture Hexagonale

Alors, comment Ã§a se compare Ã  l'Architecture Hexagonale dont on vient de parler?

Elles partagent exactement la mÃªme philosophie: **protÃ©ger la logique mÃ©tier**. Pour moi, la Clean Architecture est une version plus spÃ©cifique et plus "opinionnÃ©e" de l'Hexagonale.

* L'Architecture Hexagonale vous donne le "quoi": sÃ©parez votre appli en un "intÃ©rieur" (le domaine) et un "extÃ©rieur" (l'infrastructure) avec des ports et des adaptateurs.
* La Clean Architecture vous donne un "comment" plus dÃ©taillÃ©: elle dÃ©finit explicitement les couches Ã  l'intÃ©rieur (EntitÃ©s et Use Cases) et fournit des rÃ¨gles plus strictes sur leurs interactions.

Pensez-y comme Ã§a: l'Hexagonale a dessinÃ© la carte du monde. La Clean Architecture a ajoutÃ© les autoroutes et les panneaux de signalisation. Le chemin est plus clair.

---

## Passons Ã  la Pratique: Un Exemple Complet

La thÃ©orie, c'est bien. Le code, c'est mieux. Construisons un petit bout d'une application de gestion hÃ´teliÃ¨re. Le but: mettre Ã  jour le prix des chambres en fonction d'un nouveau prix de base et de rÃ¨gles mÃ©tier (par exemple, chaque Ã©tage a un coefficient de prix diffÃ©rent).

### Structure De Nos Fichiers

D'abord, regardez la structure du projet. C'est ce que Robert C. Martin appelle une "Screaming Architecture" (une architecture qui "crie" son intention). Votre arborescence de dossiers doit crier ce que l'application *fait*, pas quels frameworks elle utilise. Vous voyez `business`, `use-cases`, `entity`. Vous ne voyez pas `models`, `views`, `controllers` au premier niveau.

```sh
src/
â”œâ”€â”€ business/
â”‚   â”œâ”€â”€ entity/
â”‚   â”‚   â””â”€â”€ floor.ts
â”‚   â”‚   â””â”€â”€ room.ts
â”‚   â”œâ”€â”€ gateway/
â”‚   â”‚   â””â”€â”€ room.gateway.ts
â”‚   â”œâ”€â”€ use-cases/
â”‚   â”‚   â””â”€â”€ update-room-price.ts
â”œâ”€â”€ container/
â”‚   â””â”€â”€ container.ts
â”œâ”€â”€ controller/
â”‚   â”œâ”€â”€ gateway/
â”‚   â”‚   â””â”€â”€ room.repository.ts
â”‚   â”œâ”€â”€ presenter/
â”‚   â”‚   â””â”€â”€ room-presenter.json.ts
â”‚   â””â”€â”€ room.controller.ts
â””â”€â”€ tests/
    â””â”€â”€ update-price.test.ts
```

* `business/`: Le cÅ“ur de notre application. Toute la logique mÃ©tier pure vit ici. Elle n'a aucune dÃ©pendance envers le monde extÃ©rieur.
* `controller/`: Notre couche d'adaptateurs. Elle gÃ¨re les dÃ©tails techniques de la communication avec l'extÃ©rieur (implÃ©menter les gateways, les presenters, etc.).
* `container/`: Notre "usine d'assemblage". C'est lÃ  qu'on branche tout ensemble grÃ¢ce Ã  l'injection de dÃ©pendances.
* `tests/`: Les tests qui prouvent que notre logique mÃ©tier fonctionne.

---

### 1. Les EntitÃ©s: `Floor` & `Room`

Les entitÃ©s ne sont pas de simples conteneurs de donnÃ©es. Elles embarquent les rÃ¨gles mÃ©tier les plus fondamentales. C'est la logique qui est vraie pour toute l'entreprise, peu importe l'application qui l'utilise.

```ts
// business/entity/floor.ts
export class Floor {
    constructor(public floor: number) {}

    // Ã‡a, c'est une rÃ¨gle mÃ©tier fondamentale.
    getFactor() {
        if (this.floor === 1) return 1.07;
        if (this.floor === 2) return 1.22;
        if (this.floor === 3) return 1.33;
        return 1;
    }
}
```

```ts
// business/entity/room.ts
import { Floor } from "./floor";

export class Room {
    public floor: Floor;
    constructor(
        floorNumber: number,
        public number: number,
        public price: number,
    ) {
        this.floor = new Floor(floorNumber);
    }

    // Une autre rÃ¨gle mÃ©tier.
    setPrice(basePrice: number) {
        const calculatedPrice = basePrice * this.floor.getFactor();
        this.price = Math.min(Number(calculatedPrice.toFixed(2)), 200);
    }
}
```

**Pourquoi mettre de la logique ici?** Parce que la rÃ¨gle "le prix d'une chambre dÃ©pend de son Ã©tage" est une vÃ©ritÃ© fondamentale de notre business hÃ´telier. En la plaÃ§ant dans l'entitÃ©, on s'assure qu'elle est toujours respectÃ©e, partout. C'est encapsulÃ©, rÃ©utilisable et Ã§a suit le Principe de ResponsabilitÃ© Unique.

---

### 2. La Gateway: `RoomGateway`

La gateway, c'est une interface. C'est un contrat, dÃ©fini par la couche mÃ©tier, qui dit: "J'ai besoin de faire ces choses-lÃ  avec des chambres, mais je me fiche de savoir *comment* vous le faites." C'est une promesse que les couches externes devront tenir.

```ts
// business/gateway/room.gateway.ts
export interface RoomDTO {
    floor: number;
    number: number;
    price: number;
}

// Voici le contrat.
export interface RoomGateway {
    updateRoomPrice(roomNumber: number, newPrice: number): Promise<void>;
    getRooms(): Promise<Array<RoomDTO>>;
}
```

Cette interface vit dans la couche `business`, ce qui garantit que la dÃ©pendance pointe vers l'intÃ©rieur. Les use cases dÃ©pendront de cette abstraction, pas d'une classe de base de donnÃ©es concrÃ¨te.

---

### 3. Le Cas d'Utilisation: `UpdateRoomPrice`

Le use case, c'est la star du spectacle. Il reprÃ©sente une action unique que l'application peut accomplir. Il orchestre les entitÃ©s et utilise les gateways pour interagir avec le monde extÃ©rieur.

```ts
// business/use-cases/update-room-price.ts
import { Room } from "../entity/room";
import { RoomGateway } from "../gateway/room.gateway";

// Un autre contrat : comment le use case communique ses rÃ©sultats.
export interface Presenter {
    set: (rooms: Array<Room>) => void;
}

// Le use case lui-mÃªme.
export type UpdateRoomPrice = (basePrice: number, presenter: Presenter) => Promise<void>;

// Une factory pour crÃ©er le use case et injecter ses dÃ©pendances.
export const updateRoomPriceFactory = (repository: RoomGateway) => {
    return async (basePrice: number, presenter: Presenter) => {
        if (basePrice < 0) {
            throw new Error("Amount cannot be negative");
        }
        const roomsDto = await repository.getRooms();
        const rooms = roomsDto.map(r => new Room(r.floor, r.number, r.price));

        for (const room of rooms) {
            room.setPrice(basePrice); // On utilise la logique de l'entitÃ© !
            await repository.updateRoomPrice(room.number, room.price);
        }

        const updatedRooms = (await repository.getRooms()).map(
            r => new Room(r.floor, r.number, r.price)
        );
        
        // On transmet les rÃ©sultats au presenter.
        presenter.set(updatedRooms);
    };
};
```

Ce code est de la pure logique mÃ©tier. Il rÃ©cupÃ¨re des chambres, boucle dessus, dit Ã  chaque chambre de mettre Ã  jour son prix (en utilisant la mÃ©thode `setPrice` de l'entitÃ©), puis les sauvegarde. Il ne connaÃ®t rien aux bases de donnÃ©es, Ã  HTTP ou au JSON. Il ne parle qu'Ã  des abstractions (`RoomGateway`, `Presenter`).

---

### 4. L'ImplÃ©mentation De la Gateway: `RoomRepository`

Maintenant, on passe aux couches externes. Le `RoomRepository` est l'implÃ©mentation concrÃ¨te de l'interface `RoomGateway`. C'est ici qu'on Ã©crit le code de base de donnÃ©es. Pour l'exemple, j'utilise un simple tableau en mÃ©moire, mais c'est ici que votre code `Prisma`, `TypeORM` ou `node-postgres` irait.

```ts
// controller/gateway/room.repository.ts
import { RoomDTO, RoomGateway } from "../../business/gateway/room.gateway";

export class RoomRepository implements RoomGateway {
    constructor(private rooms: Array<RoomDTO>) {}

    async updateRoomPrice(roomNumber: number, newPrice: number): Promise<void> {
        const room = this.rooms.find(room => room.number === roomNumber);
        if (!room) {
            throw new Error(`Failed to find room ${roomNumber}`);
        }
        room.price = newPrice;
        return Promise.resolve();
    }

    async getRooms(): Promise<Array<RoomDTO>> {
        return Promise.resolve(this.rooms);
    }
}```

Cette classe tient la promesse faite par l'interface `RoomGateway`.

---

### 5. L'ImplÃ©mentation du Presenter : `RoomPresenterJson`

Le job du presenter, c'est de prendre les objets `Room` purs du use case et de les formater pour le monde extÃ©rieur. Ici, on les formate en objets JSON simples.

```ts
// controller/presenter/room.presenter-json.ts
import { Room } from "../../business/entity/room";

export class RoomPresenterJson {
    private r: Array<Room> = [];

    // Le use case appelle cette mÃ©thode.
    set(rooms: Array<Room>) {
        this.r = rooms;
    }

    // Le contrÃ´leur appelle cette mÃ©thode pour avoir le rÃ©sultat final.
    format() {
        return this.r.map(r => ({
            floor: r.floor.floor,
            price: r.price,
            number: r.number,
        }));
    }
}
```

Ã‡a crÃ©e une sÃ©paration magnifique. Le use case ne connaÃ®t pas le JSON. Le contrÃ´leur ne connaÃ®t pas les entitÃ©s `Room`. Le presenter fait le pont.

---

### 6. Le ContrÃ´leur: `RoomController`

Le contrÃ´leur est le point d'entrÃ©e depuis le web. Son seul travail est de parser la requÃªte, d'appeler le bon use case, et d'envoyer la rÃ©ponse formatÃ©e. C'est une couche fine et bÃªte.

```ts
// controller/room.controller.ts
import { Request, Response } from "express";
import { createContainer } from "../container/container";
import { RoomPresenterJson } from "./presenter/room-presenter.json";

const express = require('express');
const app = express();
const container = createContainer();

app.put('/rooms', async (req: Request, res: Response) => {
    // 1. On crÃ©e un nouveau presenter pour cette requÃªte.
    const roomPresenterJson = new RoomPresenterJson();
    // 2. On rÃ©cupÃ¨re le use case du conteneur et on l'exÃ©cute.
    await container.UpdateRoomPrice(200, roomPresenterJson);
    // 3. On envoie le rÃ©sultat formatÃ© par le presenter.
    res.send(roomPresenterJson.format());
});

app.listen(3000, () => console.log("Server running on http://localhost:3000"));
```

Regardez comme c'est propre. Le contrÃ´leur orchestre le flux mais ne contient aucune logique mÃ©tier.

---

### 7. Le Conteneur De DÃ©pendances

C'est ici que la magie opÃ¨re. Le conteneur est le seul endroit oÃ¹ l'on construit nos objets et oÃ¹ l'on injecte leurs dÃ©pendances. C'est l'Inversion de ContrÃ´le en action.

```ts
// container/container.ts
import { UpdateRoomPrice, updateRoomPriceFactory } from "../business/use-cases/update-room-price";
import { RoomRepository } from "../controller/gateway/room.repository";

interface Container {
    UpdateRoomPrice: UpdateRoomPrice;
}

export const createContainer = (): Container => {
    return {
        // On crÃ©e le use case, en lui injectant le repository concret.
        UpdateRoomPrice: updateRoomPriceFactory(
            new RoomRepository([
                // DonnÃ©es initiales pour notre repo en mÃ©moire.
                { floor: 0, number: 1, price: 0 },
                { floor: 1, number: 2, price: 0 },
                { floor: 2, number: 3, price: 0 },
                { floor: 3, number: 4, price: 0 },
            ])
        ),
    };
};
```

---

### 8. Le Test: LÃ  OÃ¹ Tout Prend Son Sens

Et maintenant, le meilleur pour la fin. Regardez comme il est facile de tester notre logique mÃ©tier principale.

```ts
// tests/update-price.test.ts
import assert from "assert";
import { describe, test } from "mocha";
import { createContainer } from "../container/container";
import { RoomPresenterJson } from "../controller/presenter/room-presenter.json";

describe('Update Room Price', () => {
    test('Met Ã  jour tous les prix en se basant sur un prix de 100', async () => {
        // Given
        const container = createContainer();
        const presenter = new RoomPresenterJson();

        // When on exÃ©cute le use case
        await container.UpdateRoomPrice(100, presenter);

        // Then on vÃ©rifie la sortie du presenter
        const value = presenter.format();
        assert.deepStrictEqual(value, [
            { "number": 1, "price": 100, "floor": 0 }, // 100 * 1
            { "number": 2, "price": 107, "floor": 1 }, // 100 * 1.07
            { "number": 3, "price": 122, "floor": 2 }, // 100 * 1.22
            { "number": 4, "price": 133, "floor": 3 }, // 100 * 1.33
        ]);
    });
});
```

Ce test est ultra-rapide. Il tourne en mÃ©moire. Il n'a besoin ni de base de donnÃ©es, ni de serveur web. Il teste tout notre processus mÃ©tier de bout en bout et prouve que notre logique est correcte, tout Ã§a parce qu'on a soigneusement sÃ©parÃ© nos prÃ©occupations. C'est Ã§a, la rÃ©compense.

---

## Conclusion: Codez Pour Le MÃ©tier, Pas Pour la Tech

Nous avons parcouru un long chemin, des dÃ©pendances de base Ã  l'Architecture Hexagonale, et maintenant Ã  la structure disciplinÃ©e de la Clean Architecture. La leÃ§on a toujours Ã©tÃ© la mÃªme: **faites passer votre logique mÃ©tier en premier.**

Les frameworks changeront. Les bases de donnÃ©es seront remplacÃ©es. Les interfaces utilisateur seront redessinÃ©es. Mais vos rÃ¨gles mÃ©tier fondamentales sont ce qui apporte une valeur durable. La Clean Architecture n'est pas juste un pattern; c'est une philosophie qui vous force Ã  protÃ©ger cette valeur.

Elle exige de la rigueur et un peu plus de rÃ©flexion au dÃ©part, mais la rÃ©compense est un systÃ¨me testable, maintenable, flexible et comprÃ©hensible. Vous construisez quelque chose qui peut Ã©voluer avec le business, pas quelque chose qui le freine.

Merci de m'avoir suivi dans cette aventure. Maintenant, Ã  vous de jouer et de construire le futur! ğŸš€
