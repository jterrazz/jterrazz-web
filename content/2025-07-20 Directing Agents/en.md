![](./assets/thumbnail.jpg)

# Directing AI agents

When a new feature request arrives—like adding a newsletter subscription endpoint—the requirements are often clear: a route handler, validation logic, database migration, and tests.

In the traditional workflow, understanding these requirements takes a fraction of the time. The majority is spent on the **mechanical translation** of these requirements into syntax—typing out boilerplate, looking up library specifics, and correcting minor errors.

**Directing agents** fundamentally changes this ratio. By using AI agents that can read your codebase and understand your patterns, the primary task shifts from writing code to **specifying intent**.

***

## Separating decision from translation

![](assets/split-thread.jpg)

Software development involves two distinct activities:
1. **Decision Making:** Determining how the feature should behave, what tradeoffs to accept, and how it fits into the existing architecture.
2. **Translation:** Converting those decisions into valid code.

For experienced developers, these steps have historically been inseparable. Writing code is often a form of thinking—you write a failing test, implement a naive solution, refactor, and discover architectural nuance through the act of typing. The implementation process itself serves as a feedback loop for your design.

Directed agents require you to rewire this habit. You can now separate the intent from the syntax, but this forces a change in how you "think" in code. Instead of discovering the design by wrestling with implementation details, you must learn to think through **specification**.

You still iterate, but the loop changes. You define the intent, the agent handles the translation, and you review the result. This allows you to remain in the "architect" mindset for longer, evaluating the structural implications of the code without being constantly pulled down into the mechanics of writing it.

***

## The art of specification

![](assets/architect-table.jpg)

To direct an agent effectively, you must clearly define what "done" looks like. Vague instructions yield vague code. Precise specifications yield production-ready features.

One of the most effective ways to specify intent is through **tests**. A test case is an unambiguous description of behavior.

```typescript
test('newsletter subscription flow', async () => {
    // 1. The request
    const response = await request(app)
        .post('/api/subscribe')
        .send({ email: 'user@example.com' });

    // 2. The expected outcome
    expect(response.status).toBe(200);
    expect(response.body).toEqual({ success: true });

    // 3. The side effect (state change)
    const subscriber = await db.query(
        'SELECT * FROM subscribers WHERE email = ?',
        ['user@example.com']
    );
    expect(subscriber).toBeDefined();
});
```

This code describes the *what* without dictating the *how*. It defines the interface and the expected state change.

You can then instruct the agent: *"Implement the logic to make this test pass, following our existing patterns for controllers and services."*

The agent handles the mechanical work—creating the files, importing dependencies, writing the boilerplate—while you focus on reviewing the logic.

***

## Reviewing, not proofreading

The review process when directing agents is critical. You are not just checking for syntax errors; you are verifying **logic and safety**.

- Did the agent handle edge cases (e.g., duplicate emails)?
- Is the input validation strict enough?
- Did it hallucinate a library method that doesn't exist?

The agent is a tireless worker, but it lacks judgment. It will happily write insecure or inefficient code if it fits the prompt. Your value lies in your ability to spot these architectural flaws.

***

## The trap of complacency

The danger of directed generation is the "looks good to me" syndrome. When a complete implementation appears in seconds, the temptation to accept it without deep scrutiny is high.

However, code generated by AI should be treated with the same skepticism as code written by a junior developer. It requires validation. If you stop reading the code you commit, you are no longer directing; you are gambling.

***

## Developing the skill of direction

Mastering this workflow requires a shift in skills:

1. **Clarity:** Can you articulate the requirements so clearly that a machine can execute them without guessing?
2. **Pattern Recognition:** Can you quickly scan generated code to ensure it matches your project's architectural style?
3. **Decomposition:** Can you break a complex feature down into smaller, isolated tasks that an agent can handle reliably?

By offloading the translation layer, you gain the capacity to focus on system design and quality. You build faster not because you type faster, but because you are spending your energy on the problems that actually require human intelligence.

***

*Next: We explore autonomous systems, where we move from directing agents in real-time to designing autonomous systems that work in the background.*

