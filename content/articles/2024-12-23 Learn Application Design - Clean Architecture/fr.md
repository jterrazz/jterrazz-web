![](assets/thumbnail.jpg)

# La Clean Architecture - Chapitre 3

L'architecture logicielle ne devrait pas dÃ©pendre de dÃ©tails techniques comme les bases de donnÃ©es ou les frameworks utilisÃ©s. **Les cas d'utilisation (use cases) doivent Ãªtre au centre de votre application.** C'est le fondement de la **Clean Architecture**, une mÃ©thodologie qui repose sur des couches bien dÃ©finies et dÃ©couplÃ©es, avec des dÃ©pendances strictement orientÃ©es vers le mÃ©tier.

**Navigation ğŸ“š**

1. [**Introduction: Le Design Applicatif, L'Art De Construire Des Logiciels Durables Et Ã‰volutifs**](https://www.jterrazz.com/articles/9)
	 *Les bases pour comprendre les enjeux et les objectifs d'une bonne architecture.*

2. [**Chapitre 1: Le concept de dÃ©pendances**](https://www.jterrazz.com/articles/10)
	 *Explorer les relations entre composants, l'importance des dÃ©pendances, et les principes comme SOLID.*

3. [**Chapitre 2: Comprendre Les Architectures MÃ©tier Et Technique**](https://www.jterrazz.com/articles/11)
	 *Comprendre comment isoler le mÃ©tier des prÃ©occupations techniques grÃ¢ce aux ports et adaptateurs.*

4. [**Chapitre 3: La Clean Architecture**](https://www.jterrazz.com/articles/12)
	 *DÃ©couvrir une approche centrÃ©e sur le mÃ©tier avec une structuration claire en couches.*

---

## Ce Que la Clean Architecture Implique En ThÃ©orie

Mettre en Å“uvre la Clean Architecture demande une structuration mÃ©thodique de votre application en couches indÃ©pendantes, oÃ¹ chaque couche a un rÃ´le bien dÃ©fini:

1. **Les entitÃ©s (Entities)**: Contiennent les rÃ¨gles mÃ©tier fondamentales, indÃ©pendantes des cas d'utilisation spÃ©cifiques.
2. **Les cas d'utilisation (Use Cases)**: Orchestrent les interactions entre les entitÃ©s et dÃ©finissent les rÃ¨gles spÃ©cifiques Ã  chaque besoin de l'application.
3. **Les adaptateurs d'interface (Interface Adapters)**: Traduisent les donnÃ©es entre le domaine mÃ©tier et le monde extÃ©rieur (ex.: API, UI, base de donnÃ©es).
4. **Les frameworks et drivers**: Contiennent les dÃ©tails techniques (bases de donnÃ©es, serveurs web, frameworks).

Chaque couche est indÃ©pendante et les dÃ©pendances sont strictement orientÃ©es vers le mÃ©tier.

![](assets/clean-architecture.jpg)

---

## Comparaison Avec L'architecture Hexagonale

La **Clean Architecture** et l'**architecture hexagonale** partagent une philosophie commune: **isoler la logique mÃ©tier** du reste de l'application et dÃ©coupler les couches techniques. Cependant, la Clean Architecture structure ces concepts de maniÃ¨re plus explicite en introduisant des distinctions claires entre les diffÃ©rentes couches:

1. **EntitÃ©s (Entities)**: Ces rÃ¨gles mÃ©tier fondamentales, au cÅ“ur de la Clean Architecture, sont similaires au **domaine** dans l'architecture hexagonale.
2. **Cas d'utilisation (Use Cases)**: La Clean Architecture consacre une couche spÃ©cifique aux cas d'utilisation, alors que dans l'hexagonale, ces rÃ¨gles sont souvent impliquÃ©es implicitement via les ports.
3. **Interface Adapters**: Les ports et adaptateurs de l'hexagonale trouvent leur Ã©quivalent ici. Les adaptateurs traduisent les donnÃ©es entre le mÃ©tier et les couches externes.
4. **Frameworks & Drivers**: Cette couche pÃ©riphÃ©rique regroupe les dÃ©pendances techniques (ex.: bases de donnÃ©es, API, UI), Ã©quivalente aux adaptateurs techniques de l'hexagonale.

**DiffÃ©rences clÃ©s**

â€¢ **Structure explicite**: La Clean Architecture formalise les couches (Entities, Use Cases, Interface Adapters) lÃ  oÃ¹ l'architecture hexagonale est plus abstraite.

â€¢ **Orientation mÃ©tier**: La Clean Architecture place une emphase plus forte sur les cas d'utilisation comme Ã©lÃ©ments centraux, tandis que l'hexagonale reste focalisÃ©e sur la modularitÃ© via les ports/adaptateurs.

---

## Exemple Complet: Application De Gestion De Commandes

Dans cet exemple, nous modÃ©liserons une application e-commerce oÃ¹ l'on calcule le montant total d'une commande en appliquant une rÃ©duction spÃ©cifique. Ce cas d'utilisation illustre bien la sÃ©paration entre les couches mÃ©tier et les couches techniques.

---

### Structure Des Fichiers

```sh
src/
â”œâ”€â”€ business/
â”‚   â”œâ”€â”€ entity/
â”‚   â”‚   â””â”€â”€ floor.ts
â”‚   â”‚   â””â”€â”€ room.ts
â”‚   â”œâ”€â”€ gateway/
â”‚   â”‚   â””â”€â”€ room.gateway.ts
â”‚   â”œâ”€â”€ use-cases/
â”‚   â”‚   â””â”€â”€ update-room-price.ts
â”œâ”€â”€ container/
â”‚   â””â”€â”€ container.ts
â”œâ”€â”€ controller/
â”‚   â”œâ”€â”€ gateway/
â”‚   â”‚   â””â”€â”€ room.repository.ts
â”‚   â”œâ”€â”€ presenter/
â”‚   â”‚   â””â”€â”€ room-presenter.json.ts
â”‚   â””â”€â”€ room.controller.ts
â””â”€â”€ tests/
    â””â”€â”€ update-price.test.ts
```

**Explication de la structure**

- `business/`: Contient la logique mÃ©tier (entitÃ©s, cas d'utilisation, et abstraction des gateways).
- `container/`: Configure les dÃ©pendances (injection) et assemble les diffÃ©rentes couches.
- `controller/`: ImplÃ©mente les gateways et presenters. Traduit les donnÃ©es entre le mÃ©tier et le monde extÃ©rieur.
- `tests/`: Teste isolÃ©ment les cas d'utilisation avec des mocks pour les gateways et presenters.

---

### 1. EntitÃ©s: `Floor` & `Room`

```ts
// business/entity/floor.ts
export class Floor {
    constructor(public floor: number) {}

    getFactor() {
        if (this.floor === 1) {
            return 1.07;
        }
        if (this.floor === 2) {
            return 1.22;
        }
        if (this.floor === 3) {
            return 1.33;
        }
        return 1;
    }
}
```

```ts
// business/entity/room.ts
import { Floor } from "./floor";

export class Room {
    public floor: Floor;
    constructor(
        floorNumber: number,
        public number: number,
        public price: number,
    ) {
        this.floor = new Floor(floorNumber);
    }

    setPrice(basePrice: number) {
        this.price = Math.min(Number((basePrice * this.floor.getFactor()).toFixed(2)), 200)
    }
}
```

**Pourquoi ces entitÃ©s portent des fonctions liÃ©es au mÃ©tier?**

Dans la **Clean Architecture**, les entitÃ©s comme Floor et Room reprÃ©sentent les **Enterprise Business Rules**: les rÃ¨gles mÃ©tier fondamentales de l'application. Ces rÃ¨gles encapsulent des comportements qui sont directement liÃ©s au domaine mÃ©tier de l'entreprise. Par exemple:

1. **Encapsulation des rÃ¨gles mÃ©tier**:

â€¢ La mÃ©thode getFactor de Floor traduit une rÃ¨gle mÃ©tier: chaque Ã©tage a un facteur de prix spÃ©cifique. Cette logique appartient au cÅ“ur du mÃ©tier et ne dÃ©pend pas des couches techniques.

â€¢ La mÃ©thode setPrice de Room applique une autre rÃ¨gle mÃ©tier: calculer le prix d'une chambre en fonction du facteur d'Ã©tage et limiter ce prix Ã  un maximum de 200. Cette logique est Ã©galement une responsabilitÃ© mÃ©tier.

2. **Isolation des responsabilitÃ©s**:

En plaÃ§ant ces comportements dans les entitÃ©s, on Ã©vite que les rÃ¨gles mÃ©tier soient dispersÃ©es dans les cas d'utilisation ou les couches techniques. Cela rend le code plus lisible, testable et alignÃ© avec les principes **SRP** (Single Responsibility Principle) et **encapsulation**.

3. **RÃ©utilisabilitÃ©**:

Ces entitÃ©s peuvent Ãªtre utilisÃ©es dans plusieurs cas d'utilisation sans duplication de logique. Par exemple, Room peut Ãªtre utilisÃ©e pour des calculs de prix dans diffÃ©rents contextes (affichage, mise Ã  jour des prix, gÃ©nÃ©ration de rapports).

---

### 2. Gateway: `RoomGateway`

```ts
// business/gateway/room.gateway.ts
export interface RoomDTO {
    floor: number;
    number: number;
    price: number;
}

export interface RoomGateway {
    updateRoomPrice(roomNumber: number, newPrice: number): Promise<void>
    getRooms(): Promise<Array<RoomDTO>>
}
```

Le **RoomGateway** sert d'abstraction entre la logique mÃ©tier et les dÃ©tails techniques (ex.: base de donnÃ©es). Il expose des mÃ©thodes nÃ©cessaires au mÃ©tier (updateRoomPrice, getRooms) tout en masquant les implÃ©mentations spÃ©cifiques.

---

### 3. Cas D'utilisation: `UpdateRoomPrice`

```ts
// business/use-cases/update-room-price.ts
import { Room } from "../entity/room";
import { RoomGateway } from "../gateway/room.gateway";

export interface Presenter {
    set: (rooms: Array<Room>) => void
}

export type UpdateRoomPrice = (basePrice: number, presenter: Presenter) => Promise<void>

export const updateRoomPriceFactory = (repository: RoomGateway) => {
    return async (basePrice: number, presenter: Presenter) => {
        if (basePrice < 0) {
            throw new Error('Amount cannot be negative number')
        }
        const roomsDto = await repository.getRooms()
        const rooms = roomsDto.map(r => new Room(r.floor, r.number, r.price));
        for (const room of rooms) {
            room.setPrice(basePrice)
            await repository.updateRoomPrice(room.number, room.price)
        }
        const updatedRooms = (await repository.getRooms()).map(r => new Room(r.floor, r.number, r.price));
        presenter.set(updatedRooms);
    }
}
```

Le **cas d'utilisation** UpdateRoomPrice orchestre les interactions entre le mÃ©tier et les couches externes (gateway et presenter) pour appliquer une logique spÃ©cifique: mettre Ã  jour les prix des chambres.

1. **ResponsabilitÃ© mÃ©tier**:

Ce cas d'utilisation encapsule la rÃ¨gle mÃ©tier principale: calculer et mettre Ã  jour les prix des chambres en fonction d'un prix de base, tout en validant les contraintes (ex.: montant non nÃ©gatif).

2. **Orchestration des dÃ©pendances**:

â€¢ Le **Gateway** (RoomGateway) est utilisÃ© pour accÃ©der aux donnÃ©es des chambres et persister les modifications.

â€¢ Le **Presenter** est appelÃ© Ã  la fin pour transmettre les rÃ©sultats au contrÃ´leur, garantissant que la logique mÃ©tier ne gÃ¨re pas la prÃ©sentation.

3. **TestabilitÃ© et modularitÃ©**:

Ce design rend le cas d'utilisation testable isolÃ©ment grÃ¢ce Ã  l'injection des abstractions (RoomGateway et Presenter). De plus, il peut Ãªtre modifiÃ© ou Ã©tendu sans affecter les entitÃ©s ou le contrÃ´leur.

---

### 4. ImplÃ©mentation Du Gateway CÃ´tÃ© ContrÃ´leur: `RoomRepository`

```ts
// controller/gateway/room.repository.ts
import { RoomDTO, RoomGateway } from "../../business/gateway/room.gateway";

export class RoomRepository implements RoomGateway {
    constructor(private rooms: Array<RoomDTO>) {}

    updateRoomPrice(roomNumber: number, newPrice: number): Promise<void> {
        const room = this.rooms.find(room => room.number === roomNumber);
        if (!room) {
            throw new Error(`Failed to find room ${roomNumber}`)
        }
        room.price = newPrice;
        return Promise.resolve()
    }

    getRooms(): Promise<Array<RoomDTO>> {
        return Promise.resolve(this.rooms);
    }
}
```

---

### 5. ImplÃ©mentation Du Presenter: `RoomPresenterJson`

```ts
// controller/presenter/room.presenter-json.ts
import { Room } from "../../business/entity/room";

export class RoomPresenterJson {
    private r: Array<Room> = [];

    set(rooms: Array<Room>) {
        this.r = rooms;
    }

    format() {
        return this.r.map(r => {
            return {
                floor: r.floor.floor,
                price: r.price,
                number: r.number,
            }
        })
    }
}
```

---

### 6. ContrÃ´leur: `RoomController`

```ts
// controller/room.controller.ts
import { Request, Response } from "express"
import { createContainer } from "../container/container"
import { RoomPresenterJson } from "./presenter/room-presenter.json";

// A bouger quelque part
const express = require('express')
const app = express()

const container = createContainer();

app.put('/rooms', async (req: Request, res: Response) => {
    const roomPresenterJson = new RoomPresenterJson();
    await container.UpdateRoomPrice(200, roomPresenterJson)
    res.send(roomPresenterJson.format())
})

app.listen(3000)
```

Isoler le **presenter** dans le contrÃ´leur permet de **respecter le principe de sÃ©paration des responsabilitÃ©s** et d'assurer un dÃ©couplage clair entre les couches. Dans cet exemple, le **Use Case** se concentre uniquement sur la logique mÃ©tier, sans se prÃ©occuper de la maniÃ¨re dont les rÃ©sultats seront formatÃ©s ou prÃ©sentÃ©s Ã  l'utilisateur. Cela apporte plusieurs avantages:

1. **SÃ©paration des prÃ©occupations**:

Le **Use Case** (dans UpdateRoomPrice) s'occupe exclusivement de traiter les rÃ¨gles mÃ©tier et de transmettre les donnÃ©es via une interface dÃ©finie (par exemple, `set`).
Le **Presenter** est responsable de la mise en forme des donnÃ©es pour l'utilisateur (par exemple, transformer les donnÃ©es en JSON ou tout autre format).

2. **FlexibilitÃ© et rÃ©utilisabilitÃ©**:

En isolant le **Presenter**, vous pouvez facilement changer ou ajouter des formats de prÃ©sentation (HTML, XML, JSON, etc.) sans impacter la logique mÃ©tier.

3. **ContrÃ´le explicite dans le contrÃ´leur**:

Le contrÃ´leur gÃ¨re les dÃ©tails de la prÃ©sentation et peut, par exemple, choisir quel format de **Presenter** utiliser en fonction de la requÃªte (JSON pour une API, HTML pour une page Web).

4. **TestabilitÃ© accrue**:

En dÃ©couplant le **Presenter** et en l'injectant explicitement, il devient facile de tester le **Use Case** indÃ©pendamment de la logique de prÃ©sentation. De mÃªme, le **Presenter** peut Ãªtre testÃ© sÃ©parÃ©ment pour vÃ©rifier qu'il formate correctement les donnÃ©es.

5. **Respect du principe de dÃ©pendance inversÃ©e (D de SOLID)**:

Le **Use Case** dÃ©pend d'une abstraction (RoomPresenter ou similaire) et non d'une implÃ©mentation spÃ©cifique. Cela garantit que les changements dans le format de prÃ©sentation n'affectent pas la logique mÃ©tier.

---

### 7. Conteneur: `Container`

```ts
// business/container/container.ts
import { UpdateRoomPrice, updateRoomPriceFactory } from "../business/use-cases/update-room-price"
import { RoomRepository } from "../controller/gateway/room.repository"

interface Container {
    UpdateRoomPrice: UpdateRoomPrice
}

export const createContainer = (): Container => {
    return {
        UpdateRoomPrice: updateRoomPriceFactory(new RoomRepository([
            {
                floor: 0,
                number: 1,
                price: 0,
            },
            {
                floor: 1,
                number: 2,
                price: 0,
            },
            {
                floor: 2,
                number: 3,
                price: 0,
            },
            {
                floor: 3,
                number: 4,
                price: 0,
            }
        ]))
    }
}
```

Le **conteneur** centralise la configuration et l'instanciation des dÃ©pendances de l'application. En utilisant createContainer, toutes les relations entre les cas d'utilisation (UpdateRoomPrice) et leurs dÃ©pendances (ex.: RoomRepository) sont dÃ©finies en un seul endroit.

---

### 8. Test: `CalculateOrderTotal Test`

```ts
// update-price.test.ts
import assert from "assert";
import { describe, test } from "mocha";
import { createContainer } from "./container/container";
import { RoomPresenterJson } from "./controller/presenter/room-presenter.json";

describe('Update price', () => {
    test('Update room number 1 price to 100', async () => {
        // Given
        const container = createContainer()
        const presenter = new RoomPresenterJson()

        // When
        await container.UpdateRoomPrice(100, presenter);

        // Then
        const value = presenter.format()
        assert.deepStrictEqual(value, [
            { "number": 1, "price": 100, "floor": 0 },
            { "number": 2, "price": 107, "floor": 1 },
            { "number": 3, "price": 122, "floor": 2 },
            { "number": 4, "price": 133, "floor": 3 },
        ]);
    });
})
```

Ce test est essentiel car il vÃ©rifie que la logique mÃ©tier de mise Ã  jour des prix des chambres fonctionne correctement, en appliquant les rÃ¨gles spÃ©cifiques dÃ©finies, comme les facteurs par Ã©tage ou la limite maximale de prix. GrÃ¢ce Ã  la Clean Architecture, il est facile Ã  Ã©crire et Ã  maintenir, car les dÃ©pendances sont bien sÃ©parÃ©es. L'utilisation d'un conteneur pour injecter les cas d'utilisation (UpdateRoomPrice) et d'un presenter comme RoomPresenterJson permet de simuler le comportement complet sans nÃ©cessiter de dÃ©tails techniques lourds, comme une vraie base de donnÃ©es. Cela rend le test rapide, clair et ciblÃ© sur le mÃ©tier.

---

## Pourquoi la Screaming Architecture Est Utile Ici

Dans cet exemple, la Screaming Architecture est utilisÃ©e pour reflÃ©ter le mÃ©tier:
- Les noms des fichiers (`Order`, `CalculateOrderTotal`) dÃ©crivent clairement leur rÃ´le mÃ©tier.
- Les responsabilitÃ©s sont isolÃ©es et alignÃ©es avec les besoins mÃ©tier.
- Une duplication raisonnable (comme les interfaces et classes spÃ©cifiques Ã  chaque couche) permet de garder le code clair et comprÃ©hensible.

---

## Conclusion: Une Architecture CentrÃ©e Sur Le MÃ©tier

Ã€ travers cette sÃ©rie, nous avons explorÃ© les principes fondamentaux de l'architecture logicielle, en passant des bases aux concepts avancÃ©s de la **Clean Architecture**. L'objectif principal a toujours Ã©tÃ© de **placer le mÃ©tier au centre**, tout en isolant les aspects techniques pour garantir une application modulaire, testable et Ã©volutive.

La **Clean Architecture** incarne cette vision en structurant le code en couches indÃ©pendantes, oÃ¹ chaque couche a une responsabilitÃ© unique et des dÃ©pendances strictement orientÃ©es vers le domaine mÃ©tier. Elle nous enseigne que les frameworks, bases de donnÃ©es et interfaces utilisateurs ne doivent jamais dicter l'organisation du code. Au contraire, ces dÃ©tails techniques doivent s'adapter Ã  une architecture oÃ¹ le mÃ©tier, reprÃ©sentÃ© par des entitÃ©s et des cas d'utilisation, reste immuable et autonome.

En adoptant ces principes, vous pouvez construire des applications robustes qui:

- **Ã‰voluent facilement** pour rÃ©pondre aux nouveaux besoins mÃ©tier.
- **Restent maintenables** malgrÃ© la complexitÃ© croissante.
- **Encouragent la collaboration** entre dÃ©veloppeurs grÃ¢ce Ã  une structure claire et bien dÃ©finie.

Cette approche nÃ©cessite de la rigueur et parfois des choix plus complexes au dÃ©but, mais elle offre une rÃ©silience inestimable face aux changements technologiques et organisationnels. En fin de compte, une architecture bien pensÃ©e est celle qui valorise ce qui importe le plus: **la logique mÃ©tier et la valeur qu'elle apporte Ã  l'utilisateur**.

Merci d'avoir suivi cette sÃ©rie. J'espÃ¨re qu'elle vous aura permis de mieux comprendre comment concevoir des architectures logicielles Ã©lÃ©gantes et solides, tout en gardant le mÃ©tier comme boussole principale. Ã€ vous de bÃ¢tir le futur! ğŸš€
