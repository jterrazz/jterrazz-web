import {
    type Experiment,
    ExperimentArchitecture,
    ExperimentCategory,
    ExperimentContext,
    ExperimentStatus,
} from '../domain/experiment';

const REPOSITORY_BASE_URL = 'https://github.com/jterrazz/';

const experiments: Experiment[] = [
    {
        category: ExperimentCategory.App,
        components: [
            {
                architectures: [
                    ExperimentArchitecture.Atomic,
                    ExperimentArchitecture.Clean,
                    ExperimentArchitecture.Spectrum,
                ],
                description: 'React Native Application.',
                name: 'Mobile Client',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}capitaine-mobile`),
                status: ExperimentStatus.Building,
            },
        ],
        context: ExperimentContext.Personal,
        description: 'A day to day copilot for your life.',
        longDescription:
            "Capitaine is more than just a habit tracker; it's a personal growth companion. Built with React Native and a focus on clean architecture, it helps users build sustainable habits through data-driven insights and a frictionless user experience.",
        name: 'Capitaine',
        slug: 'capitaine',
        status: ExperimentStatus.Building,
        storeLinks: {
            web: 'https://capitaine.io',
        },
        year: 2026,
    },
    {
        articleUrl: '/articles/13-lets-playfully-question-everything',
        category: ExperimentCategory.App,
        components: [
            {
                architectures: [
                    ExperimentArchitecture.DomainInfrastructure,
                    ExperimentArchitecture.Hexagonal,
                ],
                description: 'Hono server with Prisma and SQLite.',
                name: 'REST API',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}fake-news-api`),
                status: ExperimentStatus.Active,
            },
            {
                architectures: [
                    ExperimentArchitecture.Atomic,
                    ExperimentArchitecture.DomainInfrastructure,
                    ExperimentArchitecture.Spectrum,
                ],
                description: 'React Native Application.',
                name: 'Mobile Client',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}fake-news-mobile`),
                status: ExperimentStatus.Active,
            },
        ],
        context: ExperimentContext.Personal,
        description: 'A fake news app to playfully question headlines.',
        hasPrivacyPolicy: true,
        longDescription:
            'AI News is a playful application designed to challenge your critical thinking. It presents you with headlines generated by AI, and your task is to determine if they are real or fake. The system is built as a distributed application with a Hexagonal Architecture backend and a modern React Native frontend.',
        name: 'AI News',
        slug: 'ai-news',
        status: ExperimentStatus.Active,
        storeLinks: {
            appStore: 'https://apps.apple.com/us/app/ai-news-smart-world-news/id6742116038',
        },
        year: 2025,
    },
    {
        category: ExperimentCategory.App,
        components: [
            {
                architectures: [
                    ExperimentArchitecture.Atomic,
                    ExperimentArchitecture.Clean,
                    ExperimentArchitecture.Spectrum,
                ],
                description: 'Next.js application with Tailwind CSS.',
                name: 'Web Client',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}jterrazz-web`),
                status: ExperimentStatus.Active,
            },
        ],
        context: ExperimentContext.Personal,
        description:
            'A personal portfolio website showcasing my development experiments, photography, and articles.',
        longDescription:
            'Built with Next.js, TypeScript, and Tailwind CSS, this portfolio follows Clean Architecture principles. It features a custom MDX blog engine, a dynamic experiment catalog, and a responsive design that adapts to all devices. The goal was to create a performant, accessible, and aesthetically pleasing showcase of my work and thoughts.',
        name: 'Jterrazz',
        slug: 'jterrazz',
        status: ExperimentStatus.Active,
        storeLinks: {
            web: 'https://jterrazz.com',
        },
        year: 2024,
    },
    {
        category: ExperimentCategory.Lib,
        components: [
            {
                architectures: [],
                description: 'Shared TypeScript configuration.',
                name: 'TS Config',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}package-typescript`),
                status: ExperimentStatus.Active,
            },
            {
                architectures: [],
                description: 'Shared ESLint and Prettier configuration.',
                name: 'Linting Config',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}package-quality`),
                status: ExperimentStatus.Active,
            },
            {
                architectures: [],
                description: 'Jest configuration and test utilities.',
                name: 'Test Config',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}package-test`),
                status: ExperimentStatus.Active,
            },
            {
                architectures: [],
                description: 'Structured logging utility.',
                name: 'Logger Lib',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}package-logger`),
                status: ExperimentStatus.Archived,
            },
            {
                architectures: [],
                description: 'HTTP client wrapper.',
                name: 'HTTP Lib',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}package-http`),
                status: ExperimentStatus.Archived,
            },
        ],
        context: ExperimentContext.Personal,
        description: 'A collection of typescript packages for building my node.js applications.',
        longDescription:
            'A collection of independent npm packages designed to standardize development across my Node.js and TypeScript projects. It includes shared configurations for ESLint and Prettier, Jest setups, a structured logger, and an HTTP client wrapper. Each package is versioned and maintained separately to ensure modularity and ease of use.',
        name: 'Typescript Packages',
        slug: 'typescript-packages',
        status: ExperimentStatus.Active,
        year: 2024,
    },
    {
        category: ExperimentCategory.App,
        components: [
            {
                architectures: [],
                description: 'Synthetic asset platform with Chainlink oracles.',
                name: 'Defy-Dy',
                sourceUrl: new URL('https://devpost.com/software/defy-dy'),
                status: ExperimentStatus.Completed,
            },
        ],
        context: ExperimentContext.Hackathon,
        description: 'Synthetic asset platform leveraging Chainlink oracles.',
        longDescription:
            'A decentralized finance (DeFi) project built during the ETHWaterloo hackathon. Defy-Dy leverages Chainlink oracles to bring off-chain asset data (like stock prices) onto the blockchain, allowing for the creation of synthetic assets. The project explored the potential of bringing traditional financial instruments to the decentralized web.',
        name: 'Defy-Dy',
        slug: 'defy-dy',
        status: ExperimentStatus.Completed,
        year: 2019,
    },
    {
        category: ExperimentCategory.App,
        components: [
            {
                architectures: [],
                description: 'Blockchain crowdfunding platform using CVT tokens.',
                name: 'CVT Crowdfunding',
                sourceUrl: new URL('https://devpost.com/software/ethparis'),
                status: ExperimentStatus.Completed,
            },
        ],
        context: ExperimentContext.Hackathon,
        description: 'Blockchain-based crowdfunding platform using CVT tokens.',
        longDescription:
            'A blockchain-based crowdfunding platform developed at the ETHParis hackathon. It utilizes CVT tokens to facilitate secure and transparent fundraising campaigns. Smart contracts manage the distribution of funds, ensuring accountability and trust between backers and project creators.',
        name: 'CVT Crowdfunding',
        slug: 'cvt-crowdfunding',
        status: ExperimentStatus.Completed,
        year: 2019,
    },
    {
        category: ExperimentCategory.Lib,
        components: [
            {
                architectures: [],
                description: 'Infrastructure as Code for personal projects.',
                name: 'Infra',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}jterrazz-infra`),
                status: ExperimentStatus.Active,
            },
        ],
        context: ExperimentContext.Personal,
        description: 'Infrastructure as Code for my personal cloud environment.',
        longDescription:
            'A comprehensive Infrastructure as Code (IaC) repository managing my personal cloud infrastructure. Built with Terraform and Ansible, it automates the provisioning and configuration of servers, databases, and networking components. It emphasizes security, reproducibility, and scalability for hosting my various applications and experiments.',
        name: 'Infrastructure',
        slug: 'infrastructure',
        status: ExperimentStatus.Active,
        year: 2024,
    },
    {
        category: ExperimentCategory.Lib,
        components: [
            {
                architectures: [],
                description: 'AI Agents framework and implementations.',
                name: 'Agents',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}jterrazz-agents`),
                status: ExperimentStatus.Active,
            },
        ],
        context: ExperimentContext.Personal,
        description: 'Experimental framework for building autonomous AI agents.',
        longDescription:
            'An experimental playground for building and testing autonomous AI agents. This project explores different agent architectures, memory systems, and tool-use capabilities. It serves as a testbed for integrating Large Language Models (LLMs) into complex workflows and solving real-world tasks autonomously.',
        name: 'AI Agents',
        slug: 'ai-agents',
        status: ExperimentStatus.Active,
        year: 2024,
    },
    {
        category: ExperimentCategory.Lib,
        components: [
            {
                architectures: [],
                description: 'Composable AI-agent toolkit for TypeScript apps.',
                name: 'Intelligence',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}package-intelligence`),
                status: ExperimentStatus.Active,
            },
        ],
        context: ExperimentContext.Personal,
        description: 'Composable AI-agent toolkit for TypeScript apps.',
        longDescription:
            'A composable AI-agent toolkit for TypeScript applications designed with Clean Architecture principles. It provides type-safe tools, composable prompts, and resilient agent wrappers. Features include Zod-schema validation for structured outputs, retry logic for fault tolerance, and a flexible adapter system for different model providers.',
        name: 'Package Intelligence',
        slug: 'package-intelligence',
        status: ExperimentStatus.Active,
        year: 2025,
    },
    // 42 Projects
    {
        articleUrl: '/articles/6-my-journey-into-expert-systems-with-python',
        category: ExperimentCategory.System,
        components: [
            {
                architectures: [],
                description: 'Backward chaining algorithm implementation.',
                name: 'Inference Engine',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}42-expert-system`),
                status: ExperimentStatus.Completed,
            },
        ],
        context: ExperimentContext.School42,
        description:
            'Backward chaining rule based system in Python. RPN, Tree resolver, Tree representation, logic rule system, prompt.',
        longDescription:
            'A propositional logic expert system implemented in Python. It uses a backward-chaining inference engine to deduce facts based on a set of rules and initial facts. The system parses rules into a tree structure using Reverse Polish Notation (RPN) and resolves queries by traversing the tree. It handles complex logical operations including AND, OR, XOR, and implied rules.',
        name: 'Expert System',
        slug: 'expert-system',
        status: ExperimentStatus.Completed,
        year: 2019,
    },
    {
        category: ExperimentCategory.System,
        components: [
            {
                architectures: [],
                description: 'Binary exploitation and reverse engineering.',
                name: 'Exploits',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}42-override`),
                status: ExperimentStatus.Completed,
            },
        ],
        context: ExperimentContext.School42,
        description:
            'Advanced binary security experiment - Exploits and reverse engineering - x86 and x86-64 binaries.',
        longDescription:
            'The final security challenge in the 42 curriculum, focusing on advanced binary exploitation and reverse engineering. This project involves analyzing and exploiting complex x86 and x86-64 binaries, dealing with memory corruption, race conditions, and bypassing modern security protections like ASLR and DEP/NX.',
        name: 'Override',
        slug: 'override',
        status: ExperimentStatus.Completed,
        year: 2019,
    },
    {
        category: ExperimentCategory.System,
        components: [
            {
                architectures: [],
                description: 'Binary analysis and exploitation.',
                name: 'Exploits',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}42-rainfall`),
                status: ExperimentStatus.Completed,
            },
        ],
        context: ExperimentContext.School42,
        description:
            'Intermediate cybersecurity experiment, and an introduction to binary analysis - X86 binaries.',
        longDescription:
            'An intermediate-level security project focused on binary analysis and exploitation. It serves as a deep dive into how software vulnerabilities occur at the assembly level. The goal is to exploit a series of binaries to gain higher privileges, requiring a solid understanding of the stack, heap, and processor registers.',
        name: 'Rainfall',
        slug: 'rainfall',
        status: ExperimentStatus.Completed,
        year: 2019,
    },
    {
        category: ExperimentCategory.System,
        components: [
            {
                architectures: [],
                description: 'Buffer overflow and shellcode injection.',
                name: 'Exploits',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}42-snowcrash`),
                status: ExperimentStatus.Completed,
            },
        ],
        context: ExperimentContext.School42,
        description: 'Entry level cybersecurity experiment - X86 binaries.',
        longDescription:
            'The introductory security project at 42, introducing the basics of reverse engineering and binary exploitation. It consists of a series of "levels" where the user must find a way to crash a program or manipulate its execution flow to retrieve a flag, teaching the fundamentals of buffer overflows, format string vulnerabilities, and shellcode injection.',
        name: 'Snowcrash',
        slug: 'snowcrash',
        status: ExperimentStatus.Completed,
        year: 2019,
    },
    {
        category: ExperimentCategory.System,
        components: [
            {
                architectures: [],
                description: 'Process virtual machine implementation.',
                name: 'Virtual Machine',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}42-corewar`),
                status: ExperimentStatus.Completed,
            },
        ],
        context: ExperimentContext.School42,
        description:
            'Virtual machine simulating basic processors operations, with basic notions of Assembly. Written in C.',
        longDescription:
            'A competitive programming project where you build a virtual machine and an assembler. The "champions" are small assembly programs that fight for memory space in a shared arena. The project involves parsing a custom assembly language into bytecode and implementing a VM that executes this bytecode, simulating a simplified processor with registers, memory, and a cycle-based execution model.',
        name: 'Corewar',
        slug: 'corewar',
        status: ExperimentStatus.Completed,
        year: 2019,
    },
    {
        articleUrl: '/articles/3-decoding-the-magic-my-journey-building-nm-and-otool',
        category: ExperimentCategory.System,
        components: [
            {
                architectures: [],
                description: 'Mach-O binary parser.',
                name: 'Binary Parser',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}42-nm-otool`),
                status: ExperimentStatus.Completed,
            },
        ],
        context: ExperimentContext.School42,
        description:
            'Nm and otool implementation in C. Parse Mach-o files, supports fat binaries, archives and corrupted binaries.',
        longDescription:
            'A deep dive into the Mach-O binary file format used by macOS. This project requires re-implementing the Unix commands `nm` (display symbol table) and `otool` (display object file segments). It involves parsing binary headers, load commands, and symbol tables, while handling various architectures (x86_64, x86, PPC) and "fat" binaries.',
        name: 'NM Otool',
        slug: 'nm-otool',
        status: ExperimentStatus.Completed,
        year: 2019,
    },
    {
        articleUrl: '/articles/2-hashing-in-c-a-deep-dive-into-sha-256-and-md5',
        category: ExperimentCategory.System,
        components: [
            {
                architectures: [],
                description: 'MD5 and SHA-256 implementation.',
                name: 'Hashing Lib',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}42-ssl-md5`),
                status: ExperimentStatus.Completed,
            },
        ],
        context: ExperimentContext.School42,
        description:
            'OpenSSL implementation in C. Supports md5, sha1, sha256, sha224, sha512 and sha384 algorithms.',
        longDescription:
            'An implementation of standard cryptographic hashing algorithms from scratch in C. This project reproduces the behavior of the OpenSSL command-line tool. It supports MD5, SHA-256, and other SHA-2 family algorithms, requiring a precise implementation of the bitwise operations and block processing defined in their respective RFCs.',
        name: 'MD5 & SHA256',
        slug: 'md5-sha256',
        status: ExperimentStatus.Completed,
        year: 2019,
    },
    {
        articleUrl: '/articles/1-master-memory-management-i-built-my-own-malloc-and-you-should-too',
        category: ExperimentCategory.System,
        components: [
            {
                architectures: [],
                description: 'Dynamic memory allocator implementation.',
                name: 'Allocator',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}42-malloc`),
                status: ExperimentStatus.Completed,
            },
        ],
        context: ExperimentContext.School42,
        description: 'C implementation of the malloc library using mmap.',
        longDescription:
            'A complete reimplementation of the standard C dynamic memory allocation library (`malloc`, `free`, `realloc`). It interacts directly with the kernel using `mmap` and `munmap` to manage memory zones. The allocator is thread-safe and optimized for performance, using a strategy of block merging and splitting to minimize fragmentation and system calls.',
        name: 'Malloc',
        slug: 'malloc',
        status: ExperimentStatus.Completed,
        year: 2019,
    },
    {
        articleUrl: '/articles/4-building-a-program-that-writes-itself-a-quine',
        category: ExperimentCategory.System,
        components: [
            {
                architectures: [],
                description: 'Self-replicating programs.',
                name: 'Quines',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}42-dr-quine`),
                status: ExperimentStatus.Completed,
            },
        ],
        context: ExperimentContext.School42,
        description:
            "This experiment addresses auto-replication issues, and confronts you the Kleene's recursion theorem.",
        longDescription:
            "An exploration of Quinesâ€”programs that output their own source code. This project challenges you to write self-replicating programs in C, Assembly, and other languages. It dives into Kleene's recursion theorem and the theoretical underpinnings of computer viruses and self-reproducing automata.",
        name: 'Dr Quine',
        slug: 'dr-quine',
        status: ExperimentStatus.Completed,
        year: 2019,
    },
    {
        category: ExperimentCategory.System,
        components: [
            {
                architectures: [],
                description: 'Backtracking algorithm.',
                name: 'Solver',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}42-fillit`),
                status: ExperimentStatus.Completed,
            },
        ],
        context: ExperimentContext.School42,
        description: 'Algorithmic C experiment for the 42 Paris School',
        longDescription:
            'A constraint programming problem solver. The goal is to arrange a set of Tetris-like pieces (tetriminos) into the smallest possible square. It uses a backtracking algorithm to recursively place pieces, optimizing for space and efficiency. This project is a classic introduction to recursion and algorithm optimization.',
        name: 'Fillit',
        slug: 'fillit',
        status: ExperimentStatus.Completed,
        year: 2017,
    },
    {
        category: ExperimentCategory.System,
        components: [
            {
                architectures: [],
                description: 'Format string parser and output formatter.',
                name: 'Printf',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}42-ft-printf`),
                status: ExperimentStatus.Completed,
            },
        ],
        context: ExperimentContext.School42,
        description: 'Custom printf implementation in C.',
        longDescription:
            'A faithful reproduction of the C standard library `printf` function. This project teaches variadic functions in C (`stdarg.h`) and complex string formatting. It supports a wide range of format specifiers (%d, %s, %p, %x, etc.) and flags (width, precision, padding), requiring careful handling of edge cases and memory management.',
        name: 'Ft Printf',
        slug: 'ft-printf',
        status: ExperimentStatus.Completed,
        year: 2017,
    },
    {
        category: ExperimentCategory.System,
        components: [
            {
                architectures: [],
                description: 'Buffered file reader implementation.',
                name: 'File Reader',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}42-get-next-line`),
                status: ExperimentStatus.Completed,
            },
        ],
        context: ExperimentContext.School42,
        description: 'Read lines from a file descriptor.',
        longDescription:
            'A utility function that reads a line from a file descriptor, handling buffers of varying sizes. This project deals with static variables, file I/O, and dynamic memory allocation. It teaches how to efficiently manage reading text from a stream without leaks or missing data, regardless of the buffer size.',
        name: 'Get Next Line',
        slug: 'get-next-line',
        status: ExperimentStatus.Completed,
        year: 2017,
    },
    {
        category: ExperimentCategory.System,
        components: [
            {
                architectures: [],
                description: 'Max-flow algorithm implementation.',
                name: 'Graph Solver',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}42-lem-in`),
                status: ExperimentStatus.Completed,
            },
        ],
        context: ExperimentContext.School42,
        description: 'Handle a virtual anthill efficiently.',
        longDescription:
            'A graph theory project focused on finding the maximum flow through a network. Given a set of rooms and tunnels (an anthill), the goal is to move a set of ants from start to end in the fewest number of turns. It typically involves implementing algorithms like Edmonds-Karp or Dinic to find disjoint paths and optimize traffic flow.',
        name: 'Lem In',
        slug: 'lem-in',
        status: ExperimentStatus.Completed,
        year: 2018,
    },
    {
        articleUrl:
            '/articles/5-lets-dive-into-assembly-and-build-our-first-functions-intel-x86-64',
        category: ExperimentCategory.System,
        components: [
            {
                architectures: [],
                description: 'x86 Assembly implementation of libc functions.',
                name: 'ASM Lib',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}42-libft-asm`),
                status: ExperimentStatus.Completed,
            },
        ],
        context: ExperimentContext.School42,
        description: 'Basic functions implemented in Assembly using the x86 Intel syntax.',
        longDescription:
            'An introduction to x86-64 Assembly language. The goal is to rewrite standard C library functions (`strlen`, `strcpy`, `strcmp`, `write`, `read`, `strdup`) directly in assembly. This project provides a low-level understanding of how the CPU executes instructions, manages the stack, and handles system calls.',
        name: 'Libft ASM',
        slug: 'libft-asm',
        status: ExperimentStatus.Completed,
        year: 2019,
    },
    {
        category: ExperimentCategory.System,
        components: [
            {
                architectures: [],
                description: 'Standard C library implementation.',
                name: 'Std Lib',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}42-libft`),
                status: ExperimentStatus.Completed,
            },
        ],
        context: ExperimentContext.School42,
        description: 'The basic libc library used in all the 42 school experiments.',
        longDescription:
            'The very first project at 42. You must create your own C library, which will be used in future projects. It includes re-implementations of standard functions (`memset`, `strcpy`, `atoi`, etc.) and additional utility functions for linked lists and string manipulation. It enforces rigorous coding standards and memory management.',
        name: 'Libft',
        slug: 'libft',
        status: ExperimentStatus.Completed,
        year: 2017,
    },
    {
        category: ExperimentCategory.System,
        components: [
            {
                architectures: [],
                description: 'Stack sorting algorithm.',
                name: 'Sorter',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}42-push-swap`),
                status: ExperimentStatus.Completed,
            },
        ],
        context: ExperimentContext.School42,
        description:
            'Sorts data on a stack, with a limited set of instructions and limited number of moves. In C.',
        longDescription:
            'A sorting algorithm challenge. You are given two stacks and a limited set of instructions (swap, rotate, push). The goal is to sort a random list of integers using the fewest number of operations. It requires designing and implementing efficient sorting algorithms (like QuickSort or Radix Sort) adapted for a stack-based environment.',
        name: 'Push Swap',
        slug: 'push-swap',
        status: ExperimentStatus.Completed,
        year: 2018,
    },
    {
        category: ExperimentCategory.System,
        components: [
            {
                architectures: [],
                description: 'Basic C programming exercises.',
                name: 'Exercises',
                sourceUrl: new URL(`${REPOSITORY_BASE_URL}42-piscine-reloaded`),
                status: ExperimentStatus.Completed,
            },
        ],
        context: ExperimentContext.School42,
        description: 'My 42 paris school entry test.',
        longDescription:
            "A revisit of the 'Piscine' (42's intensive entry month). This project consists of a series of basic C exercises to ensure that students have retained the fundamental concepts before starting the main curriculum. It covers basic types, pointers, loops, and compilation.",
        name: 'Piscine Reloaded',
        slug: 'piscine-reloaded',
        status: ExperimentStatus.Completed,
        year: 2017,
    },
];

export const experimentsDataAccess = {
    getAll: (): Experiment[] => experiments,
    getBySlug: (slug: string): Experiment | undefined =>
        experiments.find((experiment) => experiment.slug === slug),
};
